{% extends "base.html" %}

{% block title %}–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–∞—Å—Ç—Ä–æ—é - DailyMood{% endblock %}

{% block extra_head %}
<!-- Chart.js –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫—ñ–≤ -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
{% endblock %}

{% block content %}
<div class="statistics-container card theme-panel">
    <h1 data-i18n="mood_analysis">–ê–Ω–∞–ª—ñ–∑ –≤–∞—à–æ–≥–æ –Ω–∞—Å—Ç—Ä–æ—é</h1>
    
    <section class="card theme-panel mood-overview">
        <h2 data-i18n="overall_stats">–ó–∞–≥–∞–ª—å–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <h3 data-i18n="monthly_entries">–ó–∞–ø–∏—Å—ñ–≤ –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –º—ñ—Å—è—Ü—å</h3>
                <p class="stat-number">{{ monthly_entries or 0 }}</p>
            </div>
            <div class="stat-card">
                <h3 data-i18n="most_frequent">–ù–∞–π—á–∞—Å—Ç—ñ—à–∏–π –Ω–∞—Å—Ç—Ä—ñ–π</h3>
                <p class="stat-text">{{ most_common_mood or '-' }}</p>
            </div>
            <div class="stat-card">
                <h3 data-i18n="average_mood">–°–µ—Ä–µ–¥–Ω—ñ–π –Ω–∞—Å—Ç—Ä—ñ–π</h3>
                <p class="stat-text">{{ average_mood or '-' }}</p>
            </div>
        </div>
    </section>

    <section class="mood-charts">
        <div class="chart-container">
            <h2 data-i18n="mood_trend" style="font-size:1.5em; font-weight:900; color:#ffffff; text-shadow: 0 2px 8px rgba(0,0,0,0.5); margin-bottom:16px;">–¢—Ä–µ–Ω–¥ –Ω–∞—Å—Ç—Ä–æ—é –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –º—ñ—Å—è—Ü—å</h2>
            <canvas id="moodTrendChart"></canvas>
        </div>
        
        <div class="chart-container">
            <h2 data-i18n="mood_distribution">–†–æ–∑–ø–æ–¥—ñ–ª –Ω–∞—Å—Ç—Ä–æ—ó–≤</h2>
            <canvas id="moodDistributionChart"></canvas>
        </div>
    </section>

    <section class="mood-calendar">
        <h2 data-i18n="mood_calendar">–ö–∞–ª–µ–Ω–¥–∞—Ä –Ω–∞—Å—Ç—Ä–æ—é</h2>
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
            <button id="moodPrevMonth" class="small-btn">‚óÄ</button>
            <div id="moodMonthLabel" style="font-weight:700;min-width:220px;text-align:center;"></div>
            <button id="moodNextMonth" class="small-btn">‚ñ∂</button>
        </div>
        <div class="calendar-grid" id="moodCalendar">
            <!-- Calendar content will be rendered by JavaScript for the selected month -->
        </div>
    </section>

    <section class="card theme-panel sleep-stats">
        <h2 data-i18n="sleep_statistics">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–Ω—É üí§</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <h3 data-i18n="sleep_nights">–ù–æ—á–µ–π –∑—ñ —Å–Ω–æ–º</h3>
                <p class="stat-number">{{ sleep_stats.total_nights or 0 }}</p>
            </div>
            <div class="stat-card">
                <h3 data-i18n="sleep_average">–°–µ—Ä–µ–¥–Ω—è –∫—ñ–ª—å–∫—ñ—Å—Ç—å –≥–æ–¥–∏–Ω</h3>
                <p class="stat-number">{{ "%.1f"|format(sleep_stats.average_hours) or '-' }}</p>
            </div>
            <div class="stat-card">
                <h3 data-i18n="sleep_best">–ù–∞–π–±—ñ–ª—å—à–µ –≥–æ–¥–∏–Ω</h3>
                <p class="stat-number">{{ "%.1f"|format(sleep_stats.best_night) if sleep_stats.best_night else '-' }}</p>
            </div>
            <div class="stat-card">
                <h3 data-i18n="sleep_worst">–ù–∞–π–º–µ–Ω—à–µ –≥–æ–¥–∏–Ω</h3>
                <p class="stat-number">{{ "%.1f"|format(sleep_stats.worst_night) if sleep_stats.worst_night else '-' }}</p>
            </div>
            <div class="stat-card">
                <h3 data-i18n="sleep_quality_avg">–°–µ—Ä–µ–¥–Ω—è —è–∫—ñ—Å—Ç—å</h3>
                <p class="stat-number">{{ sleep_stats.average_quality or '-' }}/4</p>
            </div>
        </div>
    </section>

    <!-- Premium Sleep Trend Section -->
    <section class="card theme-panel" id="sleepTrendSection" style="display:none;">
        <p class="muted" style="margin-bottom:12px;" data-i18n="sleep_trend_desc">–¢—Ä–µ–Ω–¥ —Ç–≤–æ–≥–æ —Å–Ω—É –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –º—ñ—Å—è—Ü—å</p>
        
        <div id="sleepTrendContent" style="display:none;">
            <div class="chart-container" style="margin-bottom:24px;">
                <h3 data-i18n="sleep_trend" style="font-size:1.3em; font-weight:900; color:#ffffff; text-shadow: 0 2px 8px rgba(0,0,0,0.5); margin-bottom:16px;">–¢—Ä–µ–Ω–¥ —Å–Ω—É –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –º—ñ—Å—è—Ü—å</h3>
                <canvas id="sleepTrendChart" style="max-height:300px;"></canvas>
            </div>
            
            <div id="sleepInsights" style="background:rgba(147,197,253,0.1); border-left:3px solid #60a5fa; padding:12px; border-radius:8px; margin-bottom:12px;">
                <h4 style="margin:0 0 8px 0; font-size:0.9em; opacity:0.9;" data-i18n="sleep_insights">üí° –Ü–Ω—Å–∞–π—Ç–∏ —Å–Ω—É</h4>
                <ul id="sleepInsightsList" style="margin:0; padding-left:20px; font-size:0.95em; line-height:1.6;"></ul>
            </div>
        </div>
        
        <div id="sleepTrendLocked" style="text-align:center; padding:20px;">
            <p style="font-size:1.1em; margin-bottom:12px;" data-i18n="premium_required">üîí –¶—è —Ñ—É–Ω–∫—Ü—ñ—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç—ñ–ª—å–∫–∏ –¥–ª—è Premium –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤</p>
            <a href="/store" class="btn" data-i18n="get_premium">–û—Ç—Ä–∏–º–∞—Ç–∏ Premium</a>
        </div>
        
        <div id="sleepTrendError" style="display:none; color:#ef4444; text-align:center; padding:12px;"></div>
    </section>

    <section class="card theme-panel" id="moodPredictorSection" style="display:none;">
        <p class="muted" style="margin-bottom:12px;" data-i18n="mood_predictor_desc">–ü–µ—Ä–µ–¥–±–∞—á–µ–Ω–Ω—è –Ω–∞—Å—Ç—Ä–æ—é –Ω–∞ –∑–∞–≤—Ç—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ç–≤–æ—î—ó —ñ—Å—Ç–æ—Ä—ñ—ó</p>
        
        <div id="predictorContent" style="display:none;">
            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin-bottom:16px;">
                <div class="stat-card">
                    <h3 data-i18n="prediction_tomorrow">–ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –∑–∞–≤—Ç—Ä–∞</h3>
                    <p id="predictionMood" class="stat-text" style="font-size:2em; margin:8px 0;">üòä</p>
                    <p id="predictionDate" class="muted" style="font-size:0.85em;"></p>
                </div>
                <div class="stat-card">
                    <h3 data-i18n="prediction_confidence">–í–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å</h3>
                    <p id="predictionConfidence" class="stat-number">0%</p>
                </div>
                <div class="stat-card">
                    <h3 data-i18n="prediction_trend">–¢—Ä–µ–Ω–¥</h3>
                    <p id="predictionTrend" class="stat-text">‚Äî</p>
                </div>
            </div>
            
            <div id="predictionInsights" style="background:rgba(96,165,250,0.1); border-left:3px solid #60a5fa; padding:12px; border-radius:8px; margin-bottom:12px;">
                <h4 style="margin:0 0 8px 0; font-size:0.9em; opacity:0.9;" data-i18n="prediction_insights">üí° –Ü–Ω—Å–∞–π—Ç–∏</h4>
                <ul id="insightsList" style="margin:0; padding-left:20px; font-size:0.95em; line-height:1.6;"></ul>
            </div>
        </div>
        
        <div id="predictorLocked" style="text-align:center; padding:20px;">
            <p style="font-size:1.1em; margin-bottom:12px;" data-i18n="premium_required">üîí –¶—è —Ñ—É–Ω–∫—Ü—ñ—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç—ñ–ª—å–∫–∏ –¥–ª—è Premium –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤</p>
            <a href="/store" class="btn" data-i18n="get_premium">–û—Ç—Ä–∏–º–∞—Ç–∏ Premium</a>
        </div>
        
        <div id="predictorError" style="display:none; color:#ef4444; text-align:center; padding:12px;"></div>
    </section>

    <section class="quotes-stats card theme-panel">
        <h2 data-i18n="quotes_stats">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ü–∏—Ç–∞—Ç</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <h3 data-i18n="saved_quotes">–ó–±–µ—Ä–µ–∂–µ–Ω–æ —Ü–∏—Ç–∞—Ç</h3>
                <p id="quotesSavedCount" class="stat-number">{{ quotes_count or 0 }}</p>
            </div>
            <div class="stat-card">
                <h3 data-i18n="favorite_quotes">–£–ª—é–±–ª–µ–Ω–∏—Ö —Ü–∏—Ç–∞—Ç</h3>
                <p id="favoriteQuotesCount" class="stat-number">{{ favorite_quotes_count or 0 }}</p>
            </div>
            <div class="stat-card">
                <h3 data-i18n="quote_of_day">–¶–∏—Ç–∞—Ç–∞ –¥–Ω—è</h3>
                <p class="quote-text" id="dailyQuoteText">{{ daily_quote or '' }}</p>
                <p class="quote-author" id="dailyQuoteAuthor">{{ daily_quote_author or '' }}</p>
            </div>
        </div>
    </section>
</div>
{% endblock %}

{% block extra_scripts %}
    <!-- Pass mood data from Flask to JavaScript -->
    <script id="moodDataScript" type="text/plain">
    {% if mood_data %}{{ mood_data | tojson }}{% else %}{}{% endif %}
    </script>
    
    <script>
    // Defensive: initialize moodData and assign backend data when available
    let moodData = { dates: [], values: [], moods: [], counts: [] };
    try {
        const scriptEl = document.getElementById('moodDataScript');
        if (scriptEl && scriptEl.textContent) {
            const parsed = JSON.parse(scriptEl.textContent);
            if (parsed && typeof parsed === 'object') {
                moodData = parsed;
            }
        }
    } catch (e) {
        console.warn('Failed to parse mood data from script tag:', e);
    }

    // i18n helper for this page
    function t_stat(key) {
        try {
            if (typeof currentLanguage === 'undefined') return '';
            const translations = currentLanguage === 'uk' ? translations_uk : translations_en;
            if (typeof translations === 'undefined') return '';
            return translations[key] || '';
        } catch(e) {
            console.warn('Translation error for key:', key);
            return '';
        }
    }

    // Helper to safely create charts only when data arrays exist
    function createTrendChart(data) {
        const trendEl = document.getElementById('moodTrendChart');
        if (!trendEl) return;
        const ctx = trendEl.getContext && trendEl.getContext('2d');
        if (!ctx) return;
        const labels = Array.isArray(data.dates) ? data.dates : [];
        const values = Array.isArray(data.values) ? data.values : [];
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: t_stat('mood_chart_label') || '–ù–∞—Å—Ç—Ä—ñ–π',
                    data: values,
                    borderColor: '#4CAF50',
                    backgroundColor: 'rgba(76, 175, 80, 0.1)',
                    tension: 0.1,
                    borderWidth: 3,
                    pointRadius: 6,
                    pointBackgroundColor: '#4CAF50',
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        labels: {
                            color: '#ffffff',
                            font: { size: 14, weight: 600 },
                            padding: 20,
                            boxWidth: 15,
                            usePointStyle: true
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.8)',
                            font: { size: 12, weight: 600 },
                            padding: 10
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)',
                            lineWidth: 1
                        }
                    },
                    x: {
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.8)',
                            font: { size: 12, weight: 600 },
                            padding: 10
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)',
                            lineWidth: 1
                        }
                    }
                }
            }
        });
    }

    function createDistributionChart(data) {
        const distEl = document.getElementById('moodDistributionChart');
        if (!distEl) return;
        const ctx = distEl.getContext && distEl.getContext('2d');
        if (!ctx) return;
        const labels = Array.isArray(data.moods) ? data.moods : [];
        const counts = Array.isArray(data.counts) ? data.counts : [];
        new Chart(ctx, {
            type: 'pie',
            data: {
                labels: labels,
                datasets: [{ data: counts, backgroundColor: ['#4CAF50','#2196F3','#FFC107','#F44336','#9C27B0'] }]
                
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        labels: {
                            color: 'rgba(255, 255, 255, 0.6)',
                            font: {
                                size: 12,
                                weight: 400
                            },
                            padding: 15,
                            boxWidth: 12
                        }
                    }
                }
            }
        });
    }

    // Month-aware mood calendar
    let moodYear = (new Date()).getFullYear();
    let moodMonth = (new Date()).getMonth();

    // Translation-aware helpers for month and weekday names
    function getTranslatedMonthName_stat(month, year) {
        try {
            if (typeof currentLanguage !== 'undefined' && currentLanguage === 'uk') {
                if (typeof translations_uk !== 'undefined' && Array.isArray(translations_uk.month_names) && translations_uk.month_names[month]) {
                    return translations_uk.month_names[month] + ' ' + year;
                }
            } else {
                if (typeof translations_en !== 'undefined' && Array.isArray(translations_en.month_names) && translations_en.month_names[month]) {
                    return translations_en.month_names[month] + ' ' + year;
                }
            }
        } catch (e) { /* ignore */ }
        const d = new Date(year, month, 1);
        const locale = currentLanguage === 'uk' ? 'uk-UA' : 'en-US';
        return d.toLocaleDateString(locale, { month: 'long', year: 'numeric' });
    }

    function getTranslatedWeekdayShort_stat(index) {
        try {
            if (typeof currentLanguage !== 'undefined' && currentLanguage === 'uk') {
                if (typeof translations_uk !== 'undefined' && Array.isArray(translations_uk.weekday_short) && translations_uk.weekday_short[index]) {
                    return translations_uk.weekday_short[index];
                }
            } else {
                if (typeof translations_en !== 'undefined' && Array.isArray(translations_en.weekday_short) && translations_en.weekday_short[index]) {
                    return translations_en.weekday_short[index];
                }
            }
        } catch (e) { /* ignore */ }
        const tmp = new Date(2020,5,index+1);
        const locale = currentLanguage === 'uk' ? 'uk-UA' : 'en-US';
        return tmp.toLocaleDateString(locale, { weekday: 'short' });
    }

    function renderMoodMonthLabel() {
        const lbl = document.getElementById('moodMonthLabel');
        if (!lbl) return;
        lbl.textContent = getTranslatedMonthName_stat(moodMonth, moodYear);
    }

    function changeMoodMonth(delta) {
        moodMonth += delta;
        if (moodMonth < 0) { moodMonth = 11; moodYear -= 1; }
        if (moodMonth > 11) { moodMonth = 0; moodYear += 1; }
        renderMoodMonthLabel();
        renderMoodCalendar(moodData, moodYear, moodMonth);
    }

    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è –∑ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è–º –Ω–∞—Å—Ç—Ä–æ—é –¥–ª—è –∑–∞–¥–∞–Ω–æ–≥–æ –º—ñ—Å—è—Ü—è
    function renderMoodCalendar(moodData, year, month) {
        const calendar = document.getElementById('moodCalendar');
        if (!calendar) return;
        calendar.innerHTML = '';

            // weekday headers (Mon..Sun) - use translations when available
            for (let i = 0; i < 7; i++) {
                const hdr = document.createElement('div'); hdr.className = 'calendar-header'; hdr.textContent = getTranslatedWeekdayShort_stat(i);
                calendar.appendChild(hdr);
            }

        // Build date->mood map from moodData
        const dateMood = {};
        if (Array.isArray(moodData.dates) && Array.isArray(moodData.values)) {
            for (let i = 0; i < Math.min(moodData.dates.length, moodData.values.length); i++) {
                const d = moodData.dates[i];
                const v = moodData.values[i];
                let moodKey = 'neutral';
                if (v > 0.66) moodKey = 'happy';
                else if (v > 0.33) moodKey = 'neutral';
                else moodKey = 'sad';
                dateMood[d] = moodKey;
            }
        }

        const firstOfMonth = new Date(year, month, 1);
        const firstWeekday = (firstOfMonth.getDay() + 6) % 7; // Mon=0..Sun=6
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        // blank cells before first day
        for (let i = 0; i < firstWeekday; i++) calendar.appendChild(Object.assign(document.createElement('div'), { className: 'calendar-day empty' }));

        // fill days
        for (let d = 1; d <= daysInMonth; d++) {
            const dateStr = `${year}-${String(month+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
            const dayCell = document.createElement('div'); dayCell.className = 'calendar-day';
            const dateNum = document.createElement('div'); dateNum.className = 'date'; dateNum.textContent = d;
            const indicator = document.createElement('div'); indicator.className = 'progress-indicator';

            const moodForDay = dateMood[dateStr];
            if (moodForDay) {
                dayCell.classList.add('mood-' + moodForDay);
                let moodLabel = '';
                if (moodForDay === 'happy') moodLabel = currentLanguage === 'uk' ? '–©–∞—Å–ª–∏–≤–∏–π' : 'Happy';
                else if (moodForDay === 'neutral') moodLabel = currentLanguage === 'uk' ? '–ù–µ–π—Ç—Ä–∞–ª—å–Ω–∏–π' : 'Neutral';
                else if (moodForDay === 'sad') moodLabel = currentLanguage === 'uk' ? '–°—É–º–Ω–∏–π' : 'Sad';
                indicator.setAttribute('title', moodLabel);
            } else {
                indicator.setAttribute('title', currentLanguage === 'uk' ? '–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö' : 'No data');
            }

            dayCell.appendChild(dateNum);
            dayCell.appendChild(indicator);
            calendar.appendChild(dayCell);
        }
    }

    // Initialize charts and calendar (safe even if moodData is empty)
    try {
        createTrendChart(moodData);
    } catch (e) {
        console.warn('Failed to create trend chart:', e);
    }
    try {
        createDistributionChart(moodData);
    } catch (e) {
        console.warn('Failed to create distribution chart:', e);
    }
    // wire month buttons
    document.addEventListener('DOMContentLoaded', () => {
        try {
            const prev = document.getElementById('moodPrevMonth');
            const next = document.getElementById('moodNextMonth');
            if (prev) prev.addEventListener('click', () => changeMoodMonth(-1));
            if (next) next.addEventListener('click', () => changeMoodMonth(1));
            renderMoodMonthLabel();
            renderMoodCalendar(moodData, moodYear, moodMonth);
        } catch (e) {
            console.warn('Failed to initialize calendar controls:', e);
        }
    });

    // Re-render month label and calendar when language changes
    window.addEventListener('languageChanged', (e) => {
        try { renderMoodMonthLabel(); } catch (e) {}
        try { renderMoodCalendar(moodData, moodYear, moodMonth); } catch (e) {}
        setTimeout(() => {
            const newLang = e.detail?.language || currentLanguage;
            window.location.href = `/statistics?lang=${newLang}&v=${new Date().getTime()}`;
        }, 300);
    });

    // Fallback: if backend didn't provide a daily quote, use client-side translations/quotes
    (function ensureDailyQuote() {
        const dqEl = document.getElementById('dailyQuoteText');
        const daEl = document.getElementById('dailyQuoteAuthor');
        if (!dqEl) return;
        const hasText = dqEl.textContent && dqEl.textContent.trim().length > 0;
        if (hasText) return;

        // First check if user has a locally saved daily quote (from favorites)
        try {
            const localDaily = localStorage.getItem('dailyMoodDailyQuote');
            const localDailyDate = localStorage.getItem('dailyMoodDailyQuoteDate');
            const today = new Date().toISOString().slice(0,10);

            // If stored and date is today, use it
            if (localDaily && localDailyDate === today) {
                dqEl.textContent = localDaily;
                if (daEl) daEl.textContent = '';
                return;
            }

            // If stored but date is older, rotate: pick a random favorite if present, otherwise fallthrough
            if (localDaily && localDailyDate && localDailyDate < today) {
                const favsRaw = (() => { try { return JSON.parse(localStorage.getItem('dailyMoodFavorites') || '[]'); } catch(e){ return []; }})();
                const favs = Array.isArray(favsRaw) ? favsRaw.map(it => (typeof it === 'string' ? { text: it, favorite: false } : (it && typeof it === 'object' ? { text: String(it.text || ''), favorite: !!it.favorite } : null))).filter(Boolean) : [];
                if (favs && favs.length) {
                    const pickObj = favs[Math.floor(Math.random() * favs.length)];
                    const pick = pickObj && pickObj.text ? pickObj.text : String(pickObj || '');
                    localStorage.setItem('dailyMoodDailyQuote', pick);
                    localStorage.setItem('dailyMoodDailyQuoteDate', today);
                    dqEl.textContent = pick;
                    if (daEl) daEl.textContent = '';
                    return;
                }
                // no favorites to pick from; fall through to translations/random
            }
        } catch (e) { /* ignore localStorage access errors */ }

        // Use localized quotes array (from static/translations/quotes.js) if available
        const lang = (typeof currentLanguage !== 'undefined') ? currentLanguage : 'uk';
        const quotesArr = (lang === 'uk') ? (window.translations_quotes_uk || []) : (window.translations_quotes_en || []);
        if (Array.isArray(quotesArr) && quotesArr.length > 0) {
            const randomQuote = quotesArr[Math.floor(Math.random() * quotesArr.length)];
            dqEl.textContent = randomQuote || '‚Äî';
            if (daEl) daEl.textContent = '';
        } else {
            const fallback = (typeof translations_en !== 'undefined' && translations_en && translations_en.quote_of_day) ? translations_en.quote_of_day : '‚Äî';
            dqEl.textContent = fallback;
            if (daEl) daEl.textContent = '';
        }
    })();

    // Diagnostic: log key initialization states for quick debugging in browser console
    try {
        console.info('DailyMood:init - moodData sizes', {dates: moodData.dates.length, values: moodData.values.length, moods: moodData.moods.length, counts: moodData.counts.length});
        console.info('DailyMood:init - Chart.js available?', typeof Chart !== 'undefined');
        console.info('DailyMood:init - dailyQuoteText present?', !!document.getElementById('dailyQuoteText'));
    } catch (e) { console.warn('DailyMood:init diagnostic failed', e); }

    // Update quotes/favorites counts from localStorage
    function updateQuoteCounts() {
        try {
            const raw = JSON.parse(localStorage.getItem('dailyMoodFavorites') || '[]');
            const items = Array.isArray(raw) ? raw.map(it => {
                if (typeof it === 'string') return { text: it, favorite: false };
                if (it && typeof it === 'object') return { text: String(it.text || ''), favorite: !!it.favorite };
                return null;
            }).filter(Boolean) : [];
            const savedCountEl = document.getElementById('quotesSavedCount');
            const favCountEl = document.getElementById('favoriteQuotesCount');
            if (savedCountEl && favCountEl) {
                const savedCount = items.length;
                const favCount = items.filter(i => !!i.favorite).length;
                savedCountEl.textContent = savedCount;
                favCountEl.textContent = favCount;
            }
        } catch(e) {
            console.warn('Failed to update quote counts:', e);
        }
    }

    window.addEventListener('favoritesUpdated', updateQuoteCounts);
    // run once on init
    updateQuoteCounts();

    // -------------------- Mood Predictor (Premium) --------------------
    (async function initMoodPredictor() {
        const section = document.getElementById('moodPredictorSection');
        const content = document.getElementById('predictorContent');
        const locked = document.getElementById('predictorLocked');
        const errorEl = document.getElementById('predictorError');
        
        if (!section) return;
        
        try {
            // Check if user is logged in and premium
            const userRes = await fetch('/api/me', { credentials: 'include' });
            if (!userRes.ok) {
                // Not logged in - hide section
                return;
            }
            
            const userData = await userRes.json();
            const user = userData.user || {};
            
            section.style.display = '';
            
            if (!user.is_premium) {
                // Show locked state
                locked.style.display = '';
                content.style.display = 'none';
                return;
            }
            
            // Premium user - fetch prediction
            const predRes = await fetch('/api/premium/mood-predictor', { credentials: 'include' });
            
            if (!predRes.ok) {
                throw new Error('Failed to load prediction');
            }
            
            const data = await predRes.json();
            
            if (data.status === 'info' || data.status === 'success') {
                locked.style.display = 'none';
                content.style.display = '';
                
                const moodEmojis = { happy: 'üòä', neutral: 'üòê', sad: 'üò¢' };
                const moodNames = currentLanguage === 'uk' ? { happy: '–©–∞—Å–ª–∏–≤–∏–π', neutral: '–ù–µ–π—Ç—Ä–∞–ª—å–Ω–∏–π', sad: '–°—É–º–Ω–∏–π' } : { happy: 'Happy', neutral: 'Neutral', sad: 'Sad' };
                const trendEmojis = { up: 'üìà', down: 'üìâ', stable: '‚û°Ô∏è' };
                const trendNames = currentLanguage === 'uk' ? { up: '–ü–æ–∫—Ä–∞—â—É—î—Ç—å—Å—è', down: '–ó–Ω–∏–∂—É—î—Ç—å—Å—è', stable: '–°—Ç–∞–±—ñ–ª—å–Ω–∏–π' } : { up: 'Improving', down: 'Declining', stable: 'Stable' };
                
                document.getElementById('predictionMood').textContent = moodEmojis[data.prediction] || 'üòê';
                const dateLocale = currentLanguage === 'uk' ? 'uk-UA' : 'en-US';
                document.getElementById('predictionDate').textContent = new Date(data.tomorrow_date).toLocaleDateString(dateLocale, { day: 'numeric', month: 'long' });
                document.getElementById('predictionConfidence').textContent = Math.round(data.confidence) + '%';
                document.getElementById('predictionTrend').textContent = (trendEmojis[data.trend] || '') + ' ' + (trendNames[data.trend] || data.trend);
                
                const insightsList = document.getElementById('insightsList');
                insightsList.innerHTML = '';
                
                if (data.insights && data.insights.length) {
                    data.insights.forEach(insight => {
                        const li = document.createElement('li');
                        li.textContent = insight;
                        insightsList.appendChild(li);
                    });
                } else if (data.message) {
                    const li = document.createElement('li');
                    li.textContent = data.message;
                    insightsList.appendChild(li);
                }
            } else {
                throw new Error(data.message || 'Unknown error');
            }
            
        } catch (err) {
            console.error('Mood Predictor error:', err);
            if (errorEl) {
                errorEl.textContent = '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –ø—Ä–æ–≥–Ω–æ–∑. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.';
                errorEl.style.display = 'block';
            }
        }
    })();

    // -------------------- Sleep Trend (Premium) --------------------
    (async function initSleepTrend() {
        const section = document.getElementById('sleepTrendSection');
        const content = document.getElementById('sleepTrendContent');
        const locked = document.getElementById('sleepTrendLocked');
        const errorEl = document.getElementById('sleepTrendError');
        
        if (!section) return;
        
        try {
            // Check if user is logged in and premium
            const userRes = await fetch('/api/me', { credentials: 'include' });
            if (!userRes.ok) {
                // Not authorized or failed to fetch user ‚Äî show locked CTA
                section.style.display = 'block';
                content.style.display = 'none';
                locked.style.display = 'block';
                return;
            }

            const userResponse = await userRes.json();
            const user = userResponse.user || userResponse;
            
            if (!user || !user.is_premium) {
                // Non-premium: show locked CTA instead of hiding the section
                section.style.display = 'block';
                content.style.display = 'none';
                locked.style.display = 'block';
                return;
            }

            // Premium user - fetch sleep trends
            const trendRes = await fetch('/api/premium/sleep-trends', { credentials: 'include' });
            const trendData = await trendRes.json();

            if (trendData.status === 'success') {
                section.style.display = 'block';
                content.style.display = 'block';
                locked.style.display = 'none';

                // Create trend chart
                createSleepTrendChart(trendData);

                // Display insights
                const insightsList = document.getElementById('sleepInsightsList');
                insightsList.innerHTML = '';
                if (Array.isArray(trendData.insights)) {
                    trendData.insights.forEach(insight => {
                        const li = document.createElement('li');
                        li.textContent = insight;
                        insightsList.appendChild(li);
                    });
                }
            } else if (trendData.status === 'info') {
                section.style.display = 'block';
                content.style.display = 'block';
                locked.style.display = 'none';
                
                const insightsList = document.getElementById('sleepInsightsList');
                insightsList.innerHTML = '';
                if (Array.isArray(trendData.insights)) {
                    trendData.insights.forEach(insight => {
                        const li = document.createElement('li');
                        li.textContent = insight;
                        insightsList.appendChild(li);
                    });
                }
            } else {
                throw new Error(trendData.message || 'Unknown error');
            }
            
        } catch (err) {
            if (errorEl) {
                errorEl.textContent = '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ç—Ä–µ–Ω–¥ —Å–Ω—É. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.';
                errorEl.style.display = 'block';
            }
        }
    })();

    function createSleepTrendChart(data) {
        const chartEl = document.getElementById('sleepTrendChart');
        if (!chartEl) return;
        const ctx = chartEl.getContext && chartEl.getContext('2d');
        if (!ctx) return;

        const labels = Array.isArray(data.dates) ? data.dates : [];
        const values = Array.isArray(data.hours) ? data.hours : [];

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: '–ì–æ–¥–∏–Ω–∏ —Å–Ω—É',
                    data: values,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    tension: 0.1,
                    borderWidth: 3,
                    pointRadius: 5,
                    pointBackgroundColor: '#3b82f6',
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        labels: {
                            color: '#ffffff',
                            font: { size: 14, weight: 600 },
                            padding: 20,
                            boxWidth: 15,
                            usePointStyle: true
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 12,
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.8)',
                            font: { size: 12, weight: 600 },
                            padding: 10
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)',
                            lineWidth: 1
                        }
                    },
                    x: {
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.8)',
                            font: { size: 12, weight: 600 },
                            padding: 10
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)',
                            lineWidth: 1
                        }
                    }
                }
            }
        });
    }
</script>
{% endblock %}