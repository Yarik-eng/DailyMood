from flask import Flask, render_template, request, jsonify
import os
    # Temporary content
    import logging
    from datetime import datetime, timedelta
    from sqlalchemy import func
    from models import db, MoodEntry
    
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[
            logging.FileHandler('app.log'),
            logging.StreamHandler()
        ]
    )
    
    # Database configuration: use SQLite file in the data/ folder
    basedir = os.path.abspath(os.path.dirname(__file__))
    db_path = os.path.join(basedir, 'data', 'dailymood.db')
    os.makedirs(os.path.dirname(db_path), exist_ok=True)
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
    # Налаштування логування
    
    app = Flask(__name__)
    
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[
            logging.FileHandler('app.log'),
            logging.StreamHandler()
        ]
    )
    
    # Database configuration: use SQLite file in the data/ folder
    
    basedir = os.path.abspath(os.path.dirname(__file__))
    db_path = os.path.join(basedir, 'data', 'dailymood.db')
    os.makedirs(os.path.dirname(db_path), exist_ok=True)
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
    # Ensure tables exist when the module is imported/run for development.
    with app.app_context():
        create_tables()
    
    @app.errorhandler(404)
    def not_found_error(error):
        logging.warning(f"404 error: {request.url}")
        return jsonify({
            'status': 'error',
            'message': 'Requested resource not found'
        }), 404
    
    @app.errorhandler(500)
    def internal_error(error):
        logging.error(f"500 error: {str(error)}")
        db.session.rollback()
        return jsonify({
            'status': 'error',
            'message': 'Internal server error occurred'
        }), 500
    
    @app.before_request
    def before_request():
        """Log each request."""
        logging.info(f"Request: {request.method} {request.url}")
    
    @app.route('/')
    def index():
        return render_template('index.html')
    
    @app.route('/about')
    def about():
        return render_template('about.html')
    
    @app.route('/favorites')
    def favorites():
        return render_template('favorites.html')
    
    @app.route('/journal')
    def journal():
        """Сторінка щоденника."""
        return render_template('journal.html')
    
    @app.route('/goals')
    def goals():
        """Сторінка цілей."""
        return render_template('goals.html')
    
    @app.route('/statistics')
    def statistics():
        """Сторінка статистики."""
        return render_template('statistics.html')
    
    @app.route('/api/journal', methods=['GET'])
    def list_entries():
        """Return a list of journal entries as JSON."""
        try:
            month = request.args.get('month')
            mood = request.args.get('mood')
            query = MoodEntry.query
            if month:
                year, month = map(int, month.split('-'))
                query = query.filter(
                    db.extract('year', MoodEntry.date) == year,
                    db.extract('month', MoodEntry.date) == month
                )
            if mood:
                query = query.filter(MoodEntry.mood == mood)
            entries = query.order_by(MoodEntry.date.desc()).all()
            return jsonify([e.to_dict() for e in entries]), 200
        except Exception as e:
            logging.error(f"Error listing entries: {str(e)}")
            return jsonify({
                'status': 'error',
                'message': f'Помилка при отриманні записів: {str(e)}'
            }), 500
from models import db, MoodEntry

from sqlalchemy import funcimport loggingimport osimport os
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

    level=logging.DEBUG,

# Database configuration: use SQLite file in the data/ folder
basedir = os.path.abspath(os.path.dirname(__file__))
db_path = os.path.join(basedir, 'data', 'dailymood.db')
os.makedirs(os.path.dirname(db_path), exist_ok=True)
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    ]

)

# Налаштування логуванняfrom sqlalchemy import funcfrom sqlalchemy import func

app = Flask(__name__)

logging.basicConfig(

# Database configuration: use SQLite file in the data/ folder

basedir = os.path.abspath(os.path.dirname(__file__))    level=logging.DEBUG,

db_path = os.path.join(basedir, 'data', 'dailymood.db')

os.makedirs(os.path.dirname(db_path), exist_ok=True)    format='%(asctime)s [%(levelname)s] %(message)s',

app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False    handlers=[from models import db, MoodEntryfrom models import db, MoodEntry



# Initialize DB        logging.FileHandler('app.log'),

db.init_app(app)

        logging.StreamHandler()

def test_db_connection():

    """Test database connection."""    ]

    try:

        with app.app_context():)# Налаштування логування# Налаштування логування

            db.engine.connect()

            logging.info("Database connection successful")

            return True

    except Exception as e:app = Flask(__name__)logging.basicConfig(logging.basicConfig(

        logging.error(f"Database connection failed: {str(e)}")

        return False



def create_tables():# Database configuration: use SQLite file in the data/ folder    level=logging.DEBUG,    level=logging.DEBUG,

    """Create database tables if they don't exist."""

    try:basedir = os.path.abspath(os.path.dirname(__file__))

        with app.app_context():

            db.create_all()db_path = os.path.join(basedir, 'data', 'dailymood.db')    format='%(asctime)s [%(levelname)s] %(message)s',    format='%(asctime)s [%(levelname)s] %(message)s',

            logging.info("Database tables created successfully")

    except Exception as e:os.makedirs(os.path.dirname(db_path), exist_ok=True)

        logging.error(f"Error creating database tables: {str(e)}")

        raiseapp.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'    handlers=[    handlers=[



# Ensure tables exist when the module is imported/run for development.app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

with app.app_context():

    create_tables()        logging.FileHandler('app.log'),        logging.FileHandler('app.log'),



@app.errorhandler(404)# Initialize DB

def not_found_error(error):

    logging.warning(f"404 error: {request.url}")db.init_app(app)        logging.StreamHandler()        logging.StreamHandler()

    return jsonify({

        'status': 'error',

        'message': 'Requested resource not found'

    }), 404def test_db_connection():    ]    ]



@app.errorhandler(500)    """Test database connection."""

def internal_error(error):

    logging.error(f"500 error: {str(error)}")    try:))

    db.session.rollback()

    return jsonify({        with app.app_context():

        'status': 'error',

        'message': 'Internal server error occurred'            db.engine.connect()

    }), 500

            logging.info("Database connection successful")

@app.before_request

def before_request():            return Trueapp = Flask(__name__)app = Flask(__name__)

    """Log each request."""

    logging.info(f"Request: {request.method} {request.url}")    except Exception as e:



@app.route('/')        logging.error(f"Database connection failed: {str(e)}")

def index():

    return render_template('index.html')        return False



@app.route('/about')# Database configuration: use SQLite file in the data/ folder# Database configuration: use SQLite file in the data/ folder

def about():

    return render_template('about.html')def create_tables():



@app.route('/favorites')    """Create database tables if they don't exist."""basedir = os.path.abspath(os.path.dirname(__file__))basedir = os.path.abspath(os.path.dirname(__file__))

def favorites():

    return render_template('favorites.html')    try:



@app.route('/journal')        with app.app_context():db_path = os.path.join(basedir, 'data', 'dailymood.db')db_path = os.path.join(basedir, 'data', 'dailymood.db')

def journal():

    """Сторінка щоденника."""            db.create_all()

    return render_template('journal.html')

            logging.info("Database tables created successfully")os.makedirs(os.path.dirname(db_path), exist_ok=True)os.makedirs(os.path.dirname(db_path), exist_ok=True)

@app.route('/goals')

def goals():    except Exception as e:

    """Сторінка цілей."""

    return render_template('goals.html')        logging.error(f"Error creating database tables: {str(e)}")app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'



@app.route('/statistics')        raise

def statistics():

    """Сторінка статистики."""app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Falseapp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    # Отримуємо дані за останній місяць

    month_ago = datetime.utcnow() - timedelta(days=30)# Ensure tables exist when the module is imported/run for development.

    

    # Кількість записів за місяцьcreate_tables()

    monthly_entries = MoodEntry.query.filter(

        MoodEntry.date >= month_ago

    ).count()

    @app.errorhandler(404)# Initialize DB# Initialize DB

    # Найчастіший настрій

    most_common = db.session.query(def not_found_error(error):

        MoodEntry.mood,

        func.count(MoodEntry.mood).label('count')    logging.warning(f"404 error: {request.url}")db.init_app(app)db.init_app(app)

    ).group_by(MoodEntry.mood).order_by(

        func.count(MoodEntry.mood).desc()    return jsonify({

    ).first()

    most_common_mood = most_common.mood if most_common else 'Немає даних'        'status': 'error',

    

    # Дані для графіків        'message': 'Requested resource not found'

    entries = MoodEntry.query.filter(

        MoodEntry.date >= month_ago    }), 404def test_db_connection():def test_db_connection():

    ).order_by(MoodEntry.date).all()

    

    mood_data = {

        'dates': [e.date.strftime('%Y-%m-%d') for e in entries],@app.errorhandler(500)    """Test database connection."""    """Test database connection."""

        'values': [1 if e.mood == 'happy' else 0.5 if e.mood == 'neutral' else 0 for e in entries],

        'moods': ['Щасливий', 'Нейтральний', 'Сумний'],def internal_error(error):

        'counts': [

            sum(1 for e in entries if e.mood == 'happy'),    logging.error(f"500 error: {str(error)}")    try:    try:

            sum(1 for e in entries if e.mood == 'neutral'),

            sum(1 for e in entries if e.mood == 'sad')    db.session.rollback()

        ]

    }    return jsonify({        with app.app_context():        with app.app_context():

    

    return render_template('statistics.html',        'status': 'error',

                         monthly_entries=monthly_entries,

                         most_common_mood=most_common_mood,        'message': 'Internal server error occurred'            db.engine.connect()            db.engine.connect()

                         mood_data=mood_data)

    }), 500

@app.route('/api/journal', methods=['GET'])

def list_entries():            logging.info("Database connection successful")            logging.info("Database connection successful")

    """Return a list of journal entries as JSON."""

    try:@app.before_request

        month = request.args.get('month')

        mood = request.args.get('mood')def before_request():            return True            return True

        

        query = MoodEntry.query    """Log each request."""

        

        if month:    logging.info(f"Request: {request.method} {request.url}")    except Exception as e:    except Exception as e:

            year, month = map(int, month.split('-'))

            query = query.filter(

                db.extract('year', MoodEntry.date) == year,

                db.extract('month', MoodEntry.date) == month@app.route('/')        logging.error(f"Database connection failed: {str(e)}")        logging.error(f"Database connection failed: {str(e)}")

            )

            def index():

        if mood:

            query = query.filter(MoodEntry.mood == mood)    return render_template('index.html')        return False        return False

            

        entries = query.order_by(MoodEntry.date.desc()).all()

        

        return jsonify([e.to_dict() for e in entries]), 200@app.route('/about')

        

    except Exception as e:def about():

        logging.error(f"Error listing entries: {str(e)}")

        return jsonify({    return render_template('about.html')def create_tables():def create_tables():

            'status': 'error',

            'message': f'Помилка при отриманні записів: {str(e)}'

        }), 500

@app.route('/favorites')    """Create database tables if they don't exist."""    """Create database tables if they don't exist."""

@app.route('/api/journal', methods=['POST'])

def add_entry():def favorites():

    """Add a journal entry."""

    try:    return render_template('favorites.html')    try:    try:

        data = request.get_json()

        

        if not all(k in data for k in ['mood', 'date', 'title']):

            return jsonify({@app.route('/journal')        with app.app_context():        with app.app_context():

                'status': 'error',

                'message': 'Необхідні поля: mood, date, title'def journal():

            }), 400

    """Сторінка щоденника."""            db.create_all()            db.create_all()

        try:

            # Convert ISO date string to Python date    return render_template('journal.html')

            date = datetime.strptime(data['date'], '%Y-%m-%d').date()

                        logging.info("Database tables created successfully")            logging.info("Database tables created successfully")

            # Convert activities list to comma-separated string

            activities = ','.join(data['activities']) if data.get('activities') else None@app.route('/goals')

            

            entry = MoodEntry(def goals():    except Exception as e:    except Exception as e:

                mood=data['mood'],

                date=date,    """Сторінка цілей."""

                title=data['title'],

                content=data.get('content'),    return render_template('goals.html')        logging.error(f"Error creating database tables: {str(e)}")        logging.error(f"Error creating database tables: {str(e)}")

                activities=activities

            )

            

            db.session.add(entry)@app.route('/statistics')        raise        raise

            db.session.commit()

def statistics():

            return jsonify({

                'status': 'success',    """Сторінка статистики."""

                'message': 'Запис успішно збережено',

                'data': entry.to_dict()    # Отримуємо дані за останній місяць

            }), 201

                month_ago = datetime.utcnow() - timedelta(days=30)# Ensure tables exist when the module is imported/run for development.# Ensure tables exist when the module is imported/run for development.

        except ValueError as ve:

            return jsonify({    

                'status': 'error',

                'message': str(ve)    # Кількість записів за місяцьcreate_tables()create_tables()

            }), 400

                monthly_entries = MoodEntry.query.filter(

    except Exception as e:

        db.session.rollback()        MoodEntry.date >= month_ago

        logging.error(f"Error adding entry: {str(e)}")

        return jsonify({    ).count()

            'status': 'error',

            'message': f'Помилка при збереженні: {str(e)}'    @app.errorhandler(404)@app.errorhandler(404)

        }), 500

    # Найчастіший настрій

@app.route('/api/journal/<int:entry_id>', methods=['PUT'])

def update_entry(entry_id):    most_common = db.session.query(def not_found_error(error):def not_found_error(error):

    """Update an existing journal entry."""

    try:        MoodEntry.mood,

        entry = MoodEntry.query.get_or_404(entry_id)

        data = request.get_json() if request.is_json else request.form        func.count(MoodEntry.mood).label('count')    logging.warning(f"404 error: {request.url}")    logging.warning(f"404 error: {request.url}")

        

        # Оновлюємо настрій якщо він наданий і валідний    ).group_by(MoodEntry.mood).order_by(

        if 'mood' in data:

            if data['mood'] not in MoodEntry.VALID_MOODS:        func.count(MoodEntry.mood).desc()    return jsonify({    return jsonify({

                return jsonify({

                    'status': 'error',    ).first()

                    'message': f'Недійсне значення настрою. Допустимі значення: {", ".join(MoodEntry.VALID_MOODS)}'

                }), 400    most_common_mood = most_common.mood if most_common else 'Немає даних'        'status': 'error',        'status': 'error',

            entry.mood = data['mood']

                

        # Оновлюємо інші поля якщо вони надані

        if 'title' in data:    # Дані для графіків        'message': 'Requested resource not found'        'message': 'Requested resource not found'

            entry.title = data['title'].strip()

                entries = MoodEntry.query.filter(

        if 'content' in data:

            entry.content = data['content'].strip()        MoodEntry.date >= month_ago    }), 404    }), 404

            

        if 'activities' in data:    ).order_by(MoodEntry.date).all()

            entry.activities = ','.join(data['activities']) if data['activities'] else None

                

        db.session.commit()

            mood_data = {

        return jsonify({

            'status': 'success',        'dates': [e.date.strftime('%Y-%m-%d') for e in entries],@app.errorhandler(500)@app.errorhandler(500)

            'message': 'Запис успішно оновлено',

            'data': entry.to_dict()        'values': [1 if e.mood == 'happy' else 0.5 if e.mood == 'neutral' else 0 for e in entries],

        }), 200

                'moods': ['Щасливий', 'Нейтральний', 'Сумний'],def internal_error(error):def internal_error(error):

    except Exception as e:

        db.session.rollback()        'counts': [

        return jsonify({

            'status': 'error',            sum(1 for e in entries if e.mood == 'happy'),    logging.error(f"500 error: {str(error)}")    logging.error(f"500 error: {str(error)}")

            'message': f'Помилка при оновленні: {str(e)}'

        }), 500            sum(1 for e in entries if e.mood == 'neutral'),



@app.route('/api/journal/<int:entry_id>', methods=['DELETE'])            sum(1 for e in entries if e.mood == 'sad')    db.session.rollback()    db.session.rollback()

def delete_entry(entry_id):

    """Delete a journal entry."""        ]

    try:

        entry = MoodEntry.query.get_or_404(entry_id)    }    return jsonify({    return jsonify({

        db.session.delete(entry)

        db.session.commit()    

        

        return jsonify({    return render_template('statistics.html',        'status': 'error',        'status': 'error',

            'status': 'success',

            'message': 'Запис успішно видалено'                         monthly_entries=monthly_entries,

        }), 200

                                 most_common_mood=most_common_mood,        'message': 'Internal server error occurred'        'message': 'Internal server error occurred'

    except Exception as e:

        db.session.rollback()                         mood_data=mood_data)

        return jsonify({

            'status': 'error',    }), 500    }), 500

            'message': f'Помилка при видаленні: {str(e)}'

        }), 500@app.route('/api/journal', methods=['GET'])



if __name__ == '__main__':def list_entries():

    # Check database connection before starting the server

    if test_db_connection():    """Return a list of journal entries as JSON."""

        logging.info("Starting Flask application")

        app.run(debug=True)    try:@app.before_request@app.before_request

    else:

        logging.error("Could not start application due to database connection failure")        month = request.args.get('month')

        exit(1)
        mood = request.args.get('mood')def before_request():def before_request():

        

        query = MoodEntry.query    """Log each request."""    """Log each request."""

        

        if month:    logging.info(f"Request: {request.method} {request.url}")    logging.info(f"Request: {request.method} {request.url}")

            year, month = map(int, month.split('-'))

            query = query.filter(

                db.extract('year', MoodEntry.date) == year,

                db.extract('month', MoodEntry.date) == month@app.route('/')@app.route('/')

            )

            def index():def index():

        if mood:

            query = query.filter(MoodEntry.mood == mood)    return render_template('index.html')    return render_template('index.html')

            

        entries = query.order_by(MoodEntry.date.desc()).all()

        

        return jsonify([e.to_dict() for e in entries]), 200@app.route('/about')@app.route('/about')

        

    except Exception as e:def about():def about():

        logging.error(f"Error listing entries: {str(e)}")

        return jsonify({    return render_template('about.html')    return render_template('about.html')

            'status': 'error',

            'message': f'Помилка при отриманні записів: {str(e)}'

        }), 500

@app.route('/favorites')@app.route('/favorites')

@app.route('/api/journal', methods=['POST'])

def add_entry():def favorites():def favorites():

    """Add a journal entry."""

    try:    return render_template('favorites.html')    return render_template('favorites.html')

        data = request.get_json()

        

        if not all(k in data for k in ['mood', 'date', 'title']):

            return jsonify({@app.route('/journal')@app.route('/journal')

                'status': 'error',

                'message': 'Необхідні поля: mood, date, title'def journal():def journal():

            }), 400

    """Сторінка щоденника."""    """Сторінка щоденника."""

        try:

            # Convert ISO date string to Python date    return render_template('journal.html')    return render_template('journal.html')

            date = datetime.strptime(data['date'], '%Y-%m-%d').date()

            

            # Convert activities list to comma-separated string

            activities = ','.join(data['activities']) if data.get('activities') else None@app.route('/goals')@app.route('/goals')

            

            entry = MoodEntry(def goals():def goals():

                mood=data['mood'],

                date=date,    """Сторінка цілей."""    """Сторінка цілей."""

                title=data['title'],

                content=data.get('content'),    return render_template('goals.html')    return render_template('goals.html')

                activities=activities

            )

            

            db.session.add(entry)@app.route('/statistics')@app.route('/statistics')

            db.session.commit()

def statistics():def statistics():

            return jsonify({

                'status': 'success',    """Сторінка статистики."""    """Сторінка статистики."""

                'message': 'Запис успішно збережено',

                'data': entry.to_dict()    # Отримуємо дані за останній місяць    # Отримуємо дані за останній місяць

            }), 201

                month_ago = datetime.utcnow() - timedelta(days=30)    month_ago = datetime.utcnow() - timedelta(days=30)

        except ValueError as ve:

            return jsonify({        

                'status': 'error',

                'message': str(ve)    # Кількість записів за місяць    # Кількість записів за місяць

            }), 400

                monthly_entries = MoodEntry.query.filter(    monthly_entries = MoodEntry.query.filter(

    except Exception as e:

        db.session.rollback()        MoodEntry.date >= month_ago        MoodEntry.date >= month_ago

        logging.error(f"Error adding entry: {str(e)}")

        return jsonify({    ).count()    ).count()

            'status': 'error',

            'message': f'Помилка при збереженні: {str(e)}'        

        }), 500

    # Найчастіший настрій    # Найчастіший настрій

@app.route('/api/journal/<int:entry_id>', methods=['PUT'])

def update_entry(entry_id):    most_common = db.session.query(    most_common = db.session.query(

    """Update an existing journal entry."""

    try:        MoodEntry.mood,        MoodEntry.mood,

        entry = MoodEntry.query.get_or_404(entry_id)

        data = request.get_json() if request.is_json else request.form        func.count(MoodEntry.mood).label('count')        func.count(MoodEntry.mood).label('count')

        

        # Оновлюємо настрій якщо він наданий і валідний    ).group_by(MoodEntry.mood).order_by(    ).group_by(MoodEntry.mood).order_by(

        if 'mood' in data:

            if data['mood'] not in MoodEntry.VALID_MOODS:        func.count(MoodEntry.mood).desc()        func.count(MoodEntry.mood).desc()

                return jsonify({

                    'status': 'error',    ).first()    ).first()

                    'message': f'Недійсне значення настрою. Допустимі значення: {", ".join(MoodEntry.VALID_MOODS)}'

                }), 400    most_common_mood = most_common.mood if most_common else 'Немає даних'    most_common_mood = most_common.mood if most_common else 'Немає даних'

            entry.mood = data['mood']

                    

        # Оновлюємо інші поля якщо вони надані

        if 'title' in data:    # Дані для графіків    # Дані для графіків

            entry.title = data['title'].strip()

                entries = MoodEntry.query.filter(    entries = MoodEntry.query.filter(

        if 'content' in data:

            entry.content = data['content'].strip()        MoodEntry.date >= month_ago        MoodEntry.date >= month_ago

            

        if 'activities' in data:    ).order_by(MoodEntry.date).all()    ).order_by(MoodEntry.date).all()

            entry.activities = ','.join(data['activities']) if data['activities'] else None

                    

        db.session.commit()

            mood_data = {    mood_data = {

        return jsonify({

            'status': 'success',        'dates': [e.date.strftime('%Y-%m-%d') for e in entries],        'dates': [e.date.strftime('%Y-%m-%d') for e in entries],

            'message': 'Запис успішно оновлено',

            'data': entry.to_dict()        'values': [1 if e.mood == 'happy' else 0.5 if e.mood == 'neutral' else 0 for e in entries],        'values': [1 if e.mood == 'happy' else 0.5 if e.mood == 'neutral' else 0 for e in entries],

        }), 200

                'moods': ['Щасливий', 'Нейтральний', 'Сумний'],        'moods': ['Щасливий', 'Нейтральний', 'Сумний'],

    except Exception as e:

        db.session.rollback()        'counts': [        'counts': [

        return jsonify({

            'status': 'error',            sum(1 for e in entries if e.mood == 'happy'),            sum(1 for e in entries if e.mood == 'happy'),

            'message': f'Помилка при оновленні: {str(e)}'

        }), 500            sum(1 for e in entries if e.mood == 'neutral'),            sum(1 for e in entries if e.mood == 'neutral'),



@app.route('/api/journal/<int:entry_id>', methods=['DELETE'])            sum(1 for e in entries if e.mood == 'sad')            sum(1 for e in entries if e.mood == 'sad')

def delete_entry(entry_id):

    """Delete a journal entry."""        ]        ]

    try:

        entry = MoodEntry.query.get_or_404(entry_id)    }    }

        db.session.delete(entry)

        db.session.commit()        

        

        return jsonify({    return render_template('statistics.html',    return render_template('statistics.html',

            'status': 'success',

            'message': 'Запис успішно видалено'                         monthly_entries=monthly_entries,                         monthly_entries=monthly_entries,

        }), 200

                                 most_common_mood=most_common_mood,                         most_common_mood=most_common_mood,

    except Exception as e:

        db.session.rollback()                         mood_data=mood_data)                         mood_data=mood_data)

        return jsonify({

            'status': 'error',

            'message': f'Помилка при видаленні: {str(e)}'

        }), 500@app.route('/api/journal', methods=['GET'])@app.route('/api/journal', methods=['GET'])



if __name__ == '__main__':def list_entries():def list_entries():

    # Check database connection before starting the server

    if test_db_connection():    """Return a list of journal entries as JSON."""    """Return a list of journal entries as JSON."""

        logging.info("Starting Flask application")

        app.run(debug=True)    try:    try:

    else:

        logging.error("Could not start application due to database connection failure")        month = request.args.get('month')        month = request.args.get('month')

        exit(1)
        mood = request.args.get('mood')        mood = request.args.get('mood')

                

        query = MoodEntry.query        query = MoodEntry.query

                

        if month:        if month:

            year, month = map(int, month.split('-'))            year, month = map(int, month.split('-'))

            query = query.filter(            query = query.filter(

                db.extract('year', MoodEntry.date) == year,                db.extract('year', MoodEntry.date) == year,

                db.extract('month', MoodEntry.date) == month                db.extract('month', MoodEntry.date) == month

            )            )

                        

        if mood:        if mood:

            query = query.filter(MoodEntry.mood == mood)            query = query.filter(MoodEntry.mood == mood)

                        

        entries = query.order_by(MoodEntry.date.desc()).all()        entries = query.order_by(MoodEntry.date.desc()).all()

                

        return jsonify([e.to_dict() for e in entries]), 200        return jsonify([e.to_dict() for e in entries]), 200

                

    except Exception as e:    except Exception as e:

        logging.error(f"Error listing entries: {str(e)}")        logging.error(f"Error listing entries: {str(e)}")

        return jsonify({        return jsonify({

            'status': 'error',            'status': 'error',

            'message': f'Помилка при отриманні записів: {str(e)}'            'message': f'Помилка при отриманні записів: {str(e)}'

        }), 500        }), 500



@app.route('/api/journal', methods=['POST'])@app.route('/api/journal', methods=['POST'])

def add_entry():def add_entry():

    """Add a journal entry."""    """Add a journal entry."""

    try:    try:

        data = request.get_json()        data = request.get_json()

                

        if not all(k in data for k in ['mood', 'date', 'title']):        if not all(k in data for k in ['mood', 'date', 'title']):

            return jsonify({            return jsonify({

                'status': 'error',                'status': 'error',

                'message': 'Необхідні поля: mood, date, title'                'message': 'Необхідні поля: mood, date, title'

            }), 400            }), 400



        try:        try:

            # Convert ISO date string to Python date            # Convert ISO date string to Python date

            date = datetime.strptime(data['date'], '%Y-%m-%d').date()            date = datetime.strptime(data['date'], '%Y-%m-%d').date()

                        

            # Convert activities list to comma-separated string            # Convert activities list to comma-separated string

            activities = ','.join(data['activities']) if data.get('activities') else None            activities = ','.join(data['activities']) if data.get('activities') else None

                        

            entry = MoodEntry(            entry = MoodEntry(

                mood=data['mood'],                mood=data['mood'],

                date=date,                date=date,

                title=data['title'],                title=data['title'],

                content=data.get('content'),                content=data.get('content'),

                activities=activities                activities=activities

            )            )

                        

            db.session.add(entry)            db.session.add(entry)

            db.session.commit()            db.session.commit()



            return jsonify({            return jsonify({

                'status': 'success',                'status': 'success',

                'message': 'Запис успішно збережено',                'message': 'Запис успішно збережено',

                'data': entry.to_dict()                'data': entry.to_dict()

            }), 201            }), 201

                        

        except ValueError as ve:        except ValueError as ve:

            return jsonify({            return jsonify({

                'status': 'error',                'status': 'error',

                'message': str(ve)                'message': str(ve)

            }), 400            }), 400

                        

    except Exception as e:    except Exception as e:

        db.session.rollback()        db.session.rollback()

        logging.error(f"Error adding entry: {str(e)}")        logging.error(f"Error adding entry: {str(e)}")

        return jsonify({        return jsonify({

            'status': 'error',            'status': 'error',

            'message': f'Помилка при збереженні: {str(e)}'            'message': f'Помилка при збереженні: {str(e)}'

        }), 500        }), 500



@app.route('/api/journal/<int:entry_id>', methods=['PUT'])@app.route('/api/journal/<int:entry_id>', methods=['PUT'])

def update_entry(entry_id):def update_entry(entry_id):

    """Update an existing journal entry."""    """Update an existing journal entry."""

    try:    try:

        entry = MoodEntry.query.get_or_404(entry_id)        entry = MoodEntry.query.get_or_404(entry_id)

        data = request.get_json() if request.is_json else request.form        data = request.get_json() if request.is_json else request.form

                

        # Оновлюємо настрій якщо він наданий і валідний        # Оновлюємо настрій якщо він наданий і валідний

        if 'mood' in data:        if 'mood' in data:

            if data['mood'] not in MoodEntry.VALID_MOODS:            if data['mood'] not in MoodEntry.VALID_MOODS:

                return jsonify({                return jsonify({

                    'status': 'error',                    'status': 'error',

                    'message': f'Недійсне значення настрою. Допустимі значення: {", ".join(MoodEntry.VALID_MOODS)}'                    'message': f'Недійсне значення настрою. Допустимі значення: {", ".join(MoodEntry.VALID_MOODS)}'

                }), 400                }), 400

            entry.mood = data['mood']            entry.mood = data['mood']

                        

        # Оновлюємо інші поля якщо вони надані        # Оновлюємо інші поля якщо вони надані

        if 'title' in data:        if 'title' in data:

            entry.title = data['title'].strip()            entry.title = data['title'].strip()

                        

        if 'content' in data:        if 'content' in data:

            entry.content = data['content'].strip()            entry.content = data['content'].strip()

                        

        if 'activities' in data:        if 'activities' in data:

            entry.activities = ','.join(data['activities']) if data['activities'] else None            entry.activities = ','.join(data['activities']) if data['activities'] else None

                        

        db.session.commit()        db.session.commit()

                

        return jsonify({        return jsonify({

            'status': 'success',            'status': 'success',

            'message': 'Запис успішно оновлено',            'message': 'Запис успішно оновлено',

            'data': entry.to_dict()            'data': entry.to_dict()

        }), 200        }), 200

                

    except Exception as e:    except Exception as e:

        db.session.rollback()        db.session.rollback()

        return jsonify({        return jsonify({

            'status': 'error',            'status': 'error',

            'message': f'Помилка при оновленні: {str(e)}'            'message': f'Помилка при оновленні: {str(e)}'

        }), 500        }), 500



@app.route('/api/journal/<int:entry_id>', methods=['DELETE'])@app.route('/api/journal/<int:entry_id>', methods=['DELETE'])

def delete_entry(entry_id):def delete_entry(entry_id):

    """Delete a journal entry."""    """Delete a journal entry."""

    try:    try:

        entry = MoodEntry.query.get_or_404(entry_id)        entry = MoodEntry.query.get_or_404(entry_id)

        db.session.delete(entry)        db.session.delete(entry)

        db.session.commit()        db.session.commit()

                

        return jsonify({        return jsonify({

            'status': 'success',            'status': 'success',

            'message': 'Запис успішно видалено'            'message': 'Запис успішно видалено'

        }), 200        }), 200

                

    except Exception as e:    except Exception as e:

        db.session.rollback()        db.session.rollback()

        return jsonify({        return jsonify({

            'status': 'error',            'status': 'error',

            'message': f'Помилка при видаленні: {str(e)}'            'message': f'Помилка при видаленні: {str(e)}'

        }), 500        }), 500



if __name__ == '__main__':if __name__ == '__main__':

    # Check database connection before starting the server    # Check database connection before starting the server

    if test_db_connection():    if test_db_connection():

        logging.info("Starting Flask application")        logging.info("Starting Flask application")

        app.run(debug=True)        app.run(debug=True)

    else:    else:

        logging.error("Could not start application due to database connection failure")        logging.error("Could not start application due to database connection failure")

        exit(1)        exit(1)